// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SFPacketStore.proto

#ifndef PROTOBUF_SFPacketStore_2eproto__INCLUDED
#define PROTOBUF_SFPacketStore_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace SFPacketStore {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SFPacketStore_2eproto();
void protobuf_AssignDesc_SFPacketStore_2eproto();
void protobuf_ShutdownFile_SFPacketStore_2eproto();

class Login;
class LoginSuccess;
class LoginFail;
class TeamInfo;
class TeamInfo_TeamMember;
class RoomMember;
class RoomMember_Member;
class EnterTeamMember;
class LeaveTeamMember;
class InvalidPacket;
class EnterLobby;
class ChatReq;
class ChatRes;
class EnterRoom;
class CreateRoom;
class LeaveRoom;
class RoomList;
class RoomList_RoomInfo;
class RoomListRefresh;
class ChangeTeam;
class LoadingStart;
class LoadingComplete;
class PlayStart;
class PlayMove;
class PlayEnd;
class PlayScoreInfo;
class PlayPlayerScore;
class PeerList;
class PeerList_PeerInfo;
class MSG_CREATE_PLAYER;
class MSG_DESTROY_PLAYER;
class PLAYER_IP;
class ADD_PEER;
class DELETE_PEER;

enum TeamType {
  NONE = -1,
  RED = 0,
  BLUE = 1
};
bool TeamType_IsValid(int value);
const TeamType TeamType_MIN = NONE;
const TeamType TeamType_MAX = BLUE;
const int TeamType_ARRAYSIZE = TeamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeamType_descriptor();
inline const ::std::string& TeamType_Name(TeamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeamType_descriptor(), value);
}
inline bool TeamType_Parse(
    const ::std::string& name, TeamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeamType>(
    TeamType_descriptor(), name, value);
}
// ===================================================================

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  void Swap(Login* other);

  // implements Message ----------------------------------------------

  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string UserName = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required string Password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:SFPacketStore.Login)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class LoginSuccess : public ::google::protobuf::Message {
 public:
  LoginSuccess();
  virtual ~LoginSuccess();

  LoginSuccess(const LoginSuccess& from);

  inline LoginSuccess& operator=(const LoginSuccess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginSuccess& default_instance();

  void Swap(LoginSuccess* other);

  // implements Message ----------------------------------------------

  LoginSuccess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginSuccess& from);
  void MergeFrom(const LoginSuccess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // required bytes UserInfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 2;
  inline const ::std::string& userinfo() const;
  inline void set_userinfo(const ::std::string& value);
  inline void set_userinfo(const char* value);
  inline void set_userinfo(const void* value, size_t size);
  inline ::std::string* mutable_userinfo();
  inline ::std::string* release_userinfo();
  inline void set_allocated_userinfo(::std::string* userinfo);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginSuccess)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* userinfo_;
  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LoginSuccess* default_instance_;
};
// -------------------------------------------------------------------

class LoginFail : public ::google::protobuf::Message {
 public:
  LoginFail();
  virtual ~LoginFail();

  LoginFail(const LoginFail& from);

  inline LoginFail& operator=(const LoginFail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginFail& default_instance();

  void Swap(LoginFail* other);

  // implements Message ----------------------------------------------

  LoginFail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginFail& from);
  void MergeFrom(const LoginFail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoginFail)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LoginFail* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfo_TeamMember : public ::google::protobuf::Message {
 public:
  TeamInfo_TeamMember();
  virtual ~TeamInfo_TeamMember();

  TeamInfo_TeamMember(const TeamInfo_TeamMember& from);

  inline TeamInfo_TeamMember& operator=(const TeamInfo_TeamMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo_TeamMember& default_instance();

  void Swap(TeamInfo_TeamMember* other);

  // implements Message ----------------------------------------------

  TeamInfo_TeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfo_TeamMember& from);
  void MergeFrom(const TeamInfo_TeamMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  inline void set_allocated_member(::std::string* member);

  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo.TeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static TeamInfo_TeamMember* default_instance_;
};
// -------------------------------------------------------------------

class TeamInfo : public ::google::protobuf::Message {
 public:
  TeamInfo();
  virtual ~TeamInfo();

  TeamInfo(const TeamInfo& from);

  inline TeamInfo& operator=(const TeamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamInfo& default_instance();

  void Swap(TeamInfo* other);

  // implements Message ----------------------------------------------

  TeamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamInfo& from);
  void MergeFrom(const TeamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TeamInfo_TeamMember TeamMember;

  // accessors -------------------------------------------------------

  // required .SFPacketStore.TeamType Type = 1 [default = RED];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::SFPacketStore::TeamType type() const;
  inline void set_type(::SFPacketStore::TeamType value);

  // repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
  inline int member_size() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 6;
  inline const ::SFPacketStore::TeamInfo_TeamMember& member(int index) const;
  inline ::SFPacketStore::TeamInfo_TeamMember* mutable_member(int index);
  inline ::SFPacketStore::TeamInfo_TeamMember* add_member();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
      member() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
      mutable_member();

  // @@protoc_insertion_point(class_scope:SFPacketStore.TeamInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember > member_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static TeamInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomMember_Member : public ::google::protobuf::Message {
 public:
  RoomMember_Member();
  virtual ~RoomMember_Member();

  RoomMember_Member(const RoomMember_Member& from);

  inline RoomMember_Member& operator=(const RoomMember_Member& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomMember_Member& default_instance();

  void Swap(RoomMember_Member* other);

  // implements Message ----------------------------------------------

  RoomMember_Member* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomMember_Member& from);
  void MergeFrom(const RoomMember_Member& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  inline void set_allocated_member(::std::string* member);

  // required int32 PlayerIndex = 2;
  inline bool has_playerindex() const;
  inline void clear_playerindex();
  static const int kPlayerIndexFieldNumber = 2;
  inline ::google::protobuf::int32 playerindex() const;
  inline void set_playerindex(::google::protobuf::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::SFPacketStore::TeamType type() const;
  inline void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomMember.Member)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_playerindex();
  inline void clear_has_playerindex();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* member_;
  ::google::protobuf::int32 playerindex_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static RoomMember_Member* default_instance_;
};
// -------------------------------------------------------------------

class RoomMember : public ::google::protobuf::Message {
 public:
  RoomMember();
  virtual ~RoomMember();

  RoomMember(const RoomMember& from);

  inline RoomMember& operator=(const RoomMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomMember& default_instance();

  void Swap(RoomMember* other);

  // implements Message ----------------------------------------------

  RoomMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomMember& from);
  void MergeFrom(const RoomMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomMember_Member Member;

  // accessors -------------------------------------------------------

  // repeated .SFPacketStore.RoomMember.Member Info = 12;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 12;
  inline const ::SFPacketStore::RoomMember_Member& info(int index) const;
  inline ::SFPacketStore::RoomMember_Member* mutable_info(int index);
  inline ::SFPacketStore::RoomMember_Member* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomMember)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomMember_Member > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static RoomMember* default_instance_;
};
// -------------------------------------------------------------------

class EnterTeamMember : public ::google::protobuf::Message {
 public:
  EnterTeamMember();
  virtual ~EnterTeamMember();

  EnterTeamMember(const EnterTeamMember& from);

  inline EnterTeamMember& operator=(const EnterTeamMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterTeamMember& default_instance();

  void Swap(EnterTeamMember* other);

  // implements Message ----------------------------------------------

  EnterTeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterTeamMember& from);
  void MergeFrom(const EnterTeamMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  inline void set_allocated_member(::std::string* member);

  // required int32 PlayerIndex = 2;
  inline bool has_playerindex() const;
  inline void clear_playerindex();
  static const int kPlayerIndexFieldNumber = 2;
  inline ::google::protobuf::int32 playerindex() const;
  inline void set_playerindex(::google::protobuf::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::SFPacketStore::TeamType type() const;
  inline void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterTeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_playerindex();
  inline void clear_has_playerindex();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* member_;
  ::google::protobuf::int32 playerindex_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static EnterTeamMember* default_instance_;
};
// -------------------------------------------------------------------

class LeaveTeamMember : public ::google::protobuf::Message {
 public:
  LeaveTeamMember();
  virtual ~LeaveTeamMember();

  LeaveTeamMember(const LeaveTeamMember& from);

  inline LeaveTeamMember& operator=(const LeaveTeamMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveTeamMember& default_instance();

  void Swap(LeaveTeamMember* other);

  // implements Message ----------------------------------------------

  LeaveTeamMember* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveTeamMember& from);
  void MergeFrom(const LeaveTeamMember& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::std::string& member() const;
  inline void set_member(const ::std::string& value);
  inline void set_member(const char* value);
  inline void set_member(const char* value, size_t size);
  inline ::std::string* mutable_member();
  inline ::std::string* release_member();
  inline void set_allocated_member(::std::string* member);

  // required int32 PlayerIndex = 2;
  inline bool has_playerindex() const;
  inline void clear_playerindex();
  static const int kPlayerIndexFieldNumber = 2;
  inline ::google::protobuf::int32 playerindex() const;
  inline void set_playerindex(::google::protobuf::int32 value);

  // required .SFPacketStore.TeamType Type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::SFPacketStore::TeamType type() const;
  inline void set_type(::SFPacketStore::TeamType value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveTeamMember)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_playerindex();
  inline void clear_has_playerindex();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* member_;
  ::google::protobuf::int32 playerindex_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LeaveTeamMember* default_instance_;
};
// -------------------------------------------------------------------

class InvalidPacket : public ::google::protobuf::Message {
 public:
  InvalidPacket();
  virtual ~InvalidPacket();

  InvalidPacket(const InvalidPacket& from);

  inline InvalidPacket& operator=(const InvalidPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvalidPacket& default_instance();

  void Swap(InvalidPacket* other);

  // implements Message ----------------------------------------------

  InvalidPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InvalidPacket& from);
  void MergeFrom(const InvalidPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Arg = 1;
  inline bool has_arg() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline const ::std::string& arg() const;
  inline void set_arg(const ::std::string& value);
  inline void set_arg(const char* value);
  inline void set_arg(const char* value, size_t size);
  inline ::std::string* mutable_arg();
  inline ::std::string* release_arg();
  inline void set_allocated_arg(::std::string* arg);

  // @@protoc_insertion_point(class_scope:SFPacketStore.InvalidPacket)
 private:
  inline void set_has_arg();
  inline void clear_has_arg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* arg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static InvalidPacket* default_instance_;
};
// -------------------------------------------------------------------

class EnterLobby : public ::google::protobuf::Message {
 public:
  EnterLobby();
  virtual ~EnterLobby();

  EnterLobby(const EnterLobby& from);

  inline EnterLobby& operator=(const EnterLobby& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterLobby& default_instance();

  void Swap(EnterLobby* other);

  // implements Message ----------------------------------------------

  EnterLobby* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterLobby& from);
  void MergeFrom(const EnterLobby& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 LobbyIndex = 1 [default = 0];
  inline bool has_lobbyindex() const;
  inline void clear_lobbyindex();
  static const int kLobbyIndexFieldNumber = 1;
  inline ::google::protobuf::int32 lobbyindex() const;
  inline void set_lobbyindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterLobby)
 private:
  inline void set_has_lobbyindex();
  inline void clear_has_lobbyindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 lobbyindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static EnterLobby* default_instance_;
};
// -------------------------------------------------------------------

class ChatReq : public ::google::protobuf::Message {
 public:
  ChatReq();
  virtual ~ChatReq();

  ChatReq(const ChatReq& from);

  inline ChatReq& operator=(const ChatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatReq& default_instance();

  void Swap(ChatReq* other);

  // implements Message ----------------------------------------------

  ChatReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatReq& from);
  void MergeFrom(const ChatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatReq)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static ChatReq* default_instance_;
};
// -------------------------------------------------------------------

class ChatRes : public ::google::protobuf::Message {
 public:
  ChatRes();
  virtual ~ChatRes();

  ChatRes(const ChatRes& from);

  inline ChatRes& operator=(const ChatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChatRes& default_instance();

  void Swap(ChatRes* other);

  // implements Message ----------------------------------------------

  ChatRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChatRes& from);
  void MergeFrom(const ChatRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Sender = 1;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 1;
  inline const ::std::string& sender() const;
  inline void set_sender(const ::std::string& value);
  inline void set_sender(const char* value);
  inline void set_sender(const char* value, size_t size);
  inline ::std::string* mutable_sender();
  inline ::std::string* release_sender();
  inline void set_allocated_sender(::std::string* sender);

  // required string Message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChatRes)
 private:
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static ChatRes* default_instance_;
};
// -------------------------------------------------------------------

class EnterRoom : public ::google::protobuf::Message {
 public:
  EnterRoom();
  virtual ~EnterRoom();

  EnterRoom(const EnterRoom& from);

  inline EnterRoom& operator=(const EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterRoom& default_instance();

  void Swap(EnterRoom* other);

  // implements Message ----------------------------------------------

  EnterRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnterRoom& from);
  void MergeFrom(const EnterRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 RoomIndex = 1;
  inline bool has_roomindex() const;
  inline void clear_roomindex();
  static const int kRoomIndexFieldNumber = 1;
  inline ::google::protobuf::int32 roomindex() const;
  inline void set_roomindex(::google::protobuf::int32 value);

  // required int32 GameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);

  // optional string Password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:SFPacketStore.EnterRoom)
 private:
  inline void set_has_roomindex();
  inline void clear_has_roomindex();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomindex_;
  ::google::protobuf::int32 gamemode_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static EnterRoom* default_instance_;
};
// -------------------------------------------------------------------

class CreateRoom : public ::google::protobuf::Message {
 public:
  CreateRoom();
  virtual ~CreateRoom();

  CreateRoom(const CreateRoom& from);

  inline CreateRoom& operator=(const CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoom& default_instance();

  void Swap(CreateRoom* other);

  // implements Message ----------------------------------------------

  CreateRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoom& from);
  void MergeFrom(const CreateRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 GameMode = 1;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 1;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);

  // optional string Password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:SFPacketStore.CreateRoom)
 private:
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* password_;
  ::google::protobuf::int32 gamemode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static CreateRoom* default_instance_;
};
// -------------------------------------------------------------------

class LeaveRoom : public ::google::protobuf::Message {
 public:
  LeaveRoom();
  virtual ~LeaveRoom();

  LeaveRoom(const LeaveRoom& from);

  inline LeaveRoom& operator=(const LeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaveRoom& default_instance();

  void Swap(LeaveRoom* other);

  // implements Message ----------------------------------------------

  LeaveRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaveRoom& from);
  void MergeFrom(const LeaveRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 Reason = 1 [default = 0];
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 1;
  inline ::google::protobuf::int32 reason() const;
  inline void set_reason(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.LeaveRoom)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LeaveRoom* default_instance_;
};
// -------------------------------------------------------------------

class RoomList_RoomInfo : public ::google::protobuf::Message {
 public:
  RoomList_RoomInfo();
  virtual ~RoomList_RoomInfo();

  RoomList_RoomInfo(const RoomList_RoomInfo& from);

  inline RoomList_RoomInfo& operator=(const RoomList_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomList_RoomInfo& default_instance();

  void Swap(RoomList_RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomList_RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomList_RoomInfo& from);
  void MergeFrom(const RoomList_RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 RoomIndex = 1;
  inline bool has_roomindex() const;
  inline void clear_roomindex();
  static const int kRoomIndexFieldNumber = 1;
  inline ::google::protobuf::int32 roomindex() const;
  inline void set_roomindex(::google::protobuf::int32 value);

  // required string RoomName = 2;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // required string RoomChief = 3;
  inline bool has_roomchief() const;
  inline void clear_roomchief();
  static const int kRoomChiefFieldNumber = 3;
  inline const ::std::string& roomchief() const;
  inline void set_roomchief(const ::std::string& value);
  inline void set_roomchief(const char* value);
  inline void set_roomchief(const char* value, size_t size);
  inline ::std::string* mutable_roomchief();
  inline ::std::string* release_roomchief();
  inline void set_allocated_roomchief(::std::string* roomchief);

  // required int32 UserCount = 4;
  inline bool has_usercount() const;
  inline void clear_usercount();
  static const int kUserCountFieldNumber = 4;
  inline ::google::protobuf::int32 usercount() const;
  inline void set_usercount(::google::protobuf::int32 value);

  // required int32 MaxUserCount = 5;
  inline bool has_maxusercount() const;
  inline void clear_maxusercount();
  static const int kMaxUserCountFieldNumber = 5;
  inline ::google::protobuf::int32 maxusercount() const;
  inline void set_maxusercount(::google::protobuf::int32 value);

  // required int32 NeedPassword = 6;
  inline bool has_needpassword() const;
  inline void clear_needpassword();
  static const int kNeedPasswordFieldNumber = 6;
  inline ::google::protobuf::int32 needpassword() const;
  inline void set_needpassword(::google::protobuf::int32 value);

  // required int32 GameMode = 7;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 7;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList.RoomInfo)
 private:
  inline void set_has_roomindex();
  inline void clear_has_roomindex();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomchief();
  inline void clear_has_roomchief();
  inline void set_has_usercount();
  inline void clear_has_usercount();
  inline void set_has_maxusercount();
  inline void clear_has_maxusercount();
  inline void set_has_needpassword();
  inline void clear_has_needpassword();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomname_;
  ::google::protobuf::int32 roomindex_;
  ::google::protobuf::int32 usercount_;
  ::std::string* roomchief_;
  ::google::protobuf::int32 maxusercount_;
  ::google::protobuf::int32 needpassword_;
  ::google::protobuf::int32 gamemode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static RoomList_RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomList : public ::google::protobuf::Message {
 public:
  RoomList();
  virtual ~RoomList();

  RoomList(const RoomList& from);

  inline RoomList& operator=(const RoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomList& default_instance();

  void Swap(RoomList* other);

  // implements Message ----------------------------------------------

  RoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomList& from);
  void MergeFrom(const RoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomList_RoomInfo RoomInfo;

  // accessors -------------------------------------------------------

  // repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
  inline int info_size() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 10;
  inline const ::SFPacketStore::RoomList_RoomInfo& info(int index) const;
  inline ::SFPacketStore::RoomList_RoomInfo* mutable_info(int index);
  inline ::SFPacketStore::RoomList_RoomInfo* add_info();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
      info() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
      mutable_info();

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo > info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static RoomList* default_instance_;
};
// -------------------------------------------------------------------

class RoomListRefresh : public ::google::protobuf::Message {
 public:
  RoomListRefresh();
  virtual ~RoomListRefresh();

  RoomListRefresh(const RoomListRefresh& from);

  inline RoomListRefresh& operator=(const RoomListRefresh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomListRefresh& default_instance();

  void Swap(RoomListRefresh* other);

  // implements Message ----------------------------------------------

  RoomListRefresh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomListRefresh& from);
  void MergeFrom(const RoomListRefresh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.RoomListRefresh)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static RoomListRefresh* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTeam : public ::google::protobuf::Message {
 public:
  ChangeTeam();
  virtual ~ChangeTeam();

  ChangeTeam(const ChangeTeam& from);

  inline ChangeTeam& operator=(const ChangeTeam& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeTeam& default_instance();

  void Swap(ChangeTeam* other);

  // implements Message ----------------------------------------------

  ChangeTeam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeTeam& from);
  void MergeFrom(const ChangeTeam& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.ChangeTeam)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static ChangeTeam* default_instance_;
};
// -------------------------------------------------------------------

class LoadingStart : public ::google::protobuf::Message {
 public:
  LoadingStart();
  virtual ~LoadingStart();

  LoadingStart(const LoadingStart& from);

  inline LoadingStart& operator=(const LoadingStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadingStart& default_instance();

  void Swap(LoadingStart* other);

  // implements Message ----------------------------------------------

  LoadingStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadingStart& from);
  void MergeFrom(const LoadingStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoadingStart)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LoadingStart* default_instance_;
};
// -------------------------------------------------------------------

class LoadingComplete : public ::google::protobuf::Message {
 public:
  LoadingComplete();
  virtual ~LoadingComplete();

  LoadingComplete(const LoadingComplete& from);

  inline LoadingComplete& operator=(const LoadingComplete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadingComplete& default_instance();

  void Swap(LoadingComplete* other);

  // implements Message ----------------------------------------------

  LoadingComplete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadingComplete& from);
  void MergeFrom(const LoadingComplete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.LoadingComplete)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static LoadingComplete* default_instance_;
};
// -------------------------------------------------------------------

class PlayStart : public ::google::protobuf::Message {
 public:
  PlayStart();
  virtual ~PlayStart();

  PlayStart(const PlayStart& from);

  inline PlayStart& operator=(const PlayStart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayStart& default_instance();

  void Swap(PlayStart* other);

  // implements Message ----------------------------------------------

  PlayStart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayStart& from);
  void MergeFrom(const PlayStart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayStart)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PlayStart* default_instance_;
};
// -------------------------------------------------------------------

class PlayMove : public ::google::protobuf::Message {
 public:
  PlayMove();
  virtual ~PlayMove();

  PlayMove(const PlayMove& from);

  inline PlayMove& operator=(const PlayMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayMove& default_instance();

  void Swap(PlayMove* other);

  // implements Message ----------------------------------------------

  PlayMove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayMove& from);
  void MergeFrom(const PlayMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float PosX = 1;
  inline bool has_posx() const;
  inline void clear_posx();
  static const int kPosXFieldNumber = 1;
  inline float posx() const;
  inline void set_posx(float value);

  // required float PosY = 2;
  inline bool has_posy() const;
  inline void clear_posy();
  static const int kPosYFieldNumber = 2;
  inline float posy() const;
  inline void set_posy(float value);

  // required float PosZ = 3;
  inline bool has_posz() const;
  inline void clear_posz();
  static const int kPosZFieldNumber = 3;
  inline float posz() const;
  inline void set_posz(float value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayMove)
 private:
  inline void set_has_posx();
  inline void clear_has_posx();
  inline void set_has_posy();
  inline void clear_has_posy();
  inline void set_has_posz();
  inline void clear_has_posz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float posx_;
  float posy_;
  float posz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PlayMove* default_instance_;
};
// -------------------------------------------------------------------

class PlayEnd : public ::google::protobuf::Message {
 public:
  PlayEnd();
  virtual ~PlayEnd();

  PlayEnd(const PlayEnd& from);

  inline PlayEnd& operator=(const PlayEnd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayEnd& default_instance();

  void Swap(PlayEnd* other);

  // implements Message ----------------------------------------------

  PlayEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayEnd& from);
  void MergeFrom(const PlayEnd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayEnd)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PlayEnd* default_instance_;
};
// -------------------------------------------------------------------

class PlayScoreInfo : public ::google::protobuf::Message {
 public:
  PlayScoreInfo();
  virtual ~PlayScoreInfo();

  PlayScoreInfo(const PlayScoreInfo& from);

  inline PlayScoreInfo& operator=(const PlayScoreInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayScoreInfo& default_instance();

  void Swap(PlayScoreInfo* other);

  // implements Message ----------------------------------------------

  PlayScoreInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayScoreInfo& from);
  void MergeFrom(const PlayScoreInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 RedKillCount = 1;
  inline bool has_redkillcount() const;
  inline void clear_redkillcount();
  static const int kRedKillCountFieldNumber = 1;
  inline ::google::protobuf::int32 redkillcount() const;
  inline void set_redkillcount(::google::protobuf::int32 value);

  // required int32 BlueKillCount = 2;
  inline bool has_bluekillcount() const;
  inline void clear_bluekillcount();
  static const int kBlueKillCountFieldNumber = 2;
  inline ::google::protobuf::int32 bluekillcount() const;
  inline void set_bluekillcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayScoreInfo)
 private:
  inline void set_has_redkillcount();
  inline void clear_has_redkillcount();
  inline void set_has_bluekillcount();
  inline void clear_has_bluekillcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 redkillcount_;
  ::google::protobuf::int32 bluekillcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PlayScoreInfo* default_instance_;
};
// -------------------------------------------------------------------

class PlayPlayerScore : public ::google::protobuf::Message {
 public:
  PlayPlayerScore();
  virtual ~PlayPlayerScore();

  PlayPlayerScore(const PlayPlayerScore& from);

  inline PlayPlayerScore& operator=(const PlayPlayerScore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayPlayerScore& default_instance();

  void Swap(PlayPlayerScore* other);

  // implements Message ----------------------------------------------

  PlayPlayerScore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayPlayerScore& from);
  void MergeFrom(const PlayPlayerScore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 teamtype = 2;
  inline bool has_teamtype() const;
  inline void clear_teamtype();
  static const int kTeamtypeFieldNumber = 2;
  inline ::google::protobuf::int32 teamtype() const;
  inline void set_teamtype(::google::protobuf::int32 value);

  // required int32 kill = 3;
  inline bool has_kill() const;
  inline void clear_kill();
  static const int kKillFieldNumber = 3;
  inline ::google::protobuf::int32 kill() const;
  inline void set_kill(::google::protobuf::int32 value);

  // required int32 death = 4;
  inline bool has_death() const;
  inline void clear_death();
  static const int kDeathFieldNumber = 4;
  inline ::google::protobuf::int32 death() const;
  inline void set_death(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PlayPlayerScore)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_teamtype();
  inline void clear_has_teamtype();
  inline void set_has_kill();
  inline void clear_has_kill();
  inline void set_has_death();
  inline void clear_has_death();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 teamtype_;
  ::google::protobuf::int32 kill_;
  ::google::protobuf::int32 death_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PlayPlayerScore* default_instance_;
};
// -------------------------------------------------------------------

class PeerList_PeerInfo : public ::google::protobuf::Message {
 public:
  PeerList_PeerInfo();
  virtual ~PeerList_PeerInfo();

  PeerList_PeerInfo(const PeerList_PeerInfo& from);

  inline PeerList_PeerInfo& operator=(const PeerList_PeerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerList_PeerInfo& default_instance();

  void Swap(PeerList_PeerInfo* other);

  // implements Message ----------------------------------------------

  PeerList_PeerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerList_PeerInfo& from);
  void MergeFrom(const PeerList_PeerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // required bytes Info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const void* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList.PeerInfo)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* info_;
  ::google::protobuf::int32 serial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PeerList_PeerInfo* default_instance_;
};
// -------------------------------------------------------------------

class PeerList : public ::google::protobuf::Message {
 public:
  PeerList();
  virtual ~PeerList();

  PeerList(const PeerList& from);

  inline PeerList& operator=(const PeerList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerList& default_instance();

  void Swap(PeerList* other);

  // implements Message ----------------------------------------------

  PeerList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerList& from);
  void MergeFrom(const PeerList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PeerList_PeerInfo PeerInfo;

  // accessors -------------------------------------------------------

  // repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
  inline int peer_size() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 10;
  inline const ::SFPacketStore::PeerList_PeerInfo& peer(int index) const;
  inline ::SFPacketStore::PeerList_PeerInfo* mutable_peer(int index);
  inline ::SFPacketStore::PeerList_PeerInfo* add_peer();
  inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
      peer() const;
  inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
      mutable_peer();

  // @@protoc_insertion_point(class_scope:SFPacketStore.PeerList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo > peer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PeerList* default_instance_;
};
// -------------------------------------------------------------------

class MSG_CREATE_PLAYER : public ::google::protobuf::Message {
 public:
  MSG_CREATE_PLAYER();
  virtual ~MSG_CREATE_PLAYER();

  MSG_CREATE_PLAYER(const MSG_CREATE_PLAYER& from);

  inline MSG_CREATE_PLAYER& operator=(const MSG_CREATE_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_CREATE_PLAYER& default_instance();

  void Swap(MSG_CREATE_PLAYER* other);

  // implements Message ----------------------------------------------

  MSG_CREATE_PLAYER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_CREATE_PLAYER& from);
  void MergeFrom(const MSG_CREATE_PLAYER& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // required int32 spawnindex = 2;
  inline bool has_spawnindex() const;
  inline void clear_spawnindex();
  static const int kSpawnindexFieldNumber = 2;
  inline ::google::protobuf::int32 spawnindex() const;
  inline void set_spawnindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_CREATE_PLAYER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_spawnindex();
  inline void clear_has_spawnindex();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 serial_;
  ::google::protobuf::int32 spawnindex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static MSG_CREATE_PLAYER* default_instance_;
};
// -------------------------------------------------------------------

class MSG_DESTROY_PLAYER : public ::google::protobuf::Message {
 public:
  MSG_DESTROY_PLAYER();
  virtual ~MSG_DESTROY_PLAYER();

  MSG_DESTROY_PLAYER(const MSG_DESTROY_PLAYER& from);

  inline MSG_DESTROY_PLAYER& operator=(const MSG_DESTROY_PLAYER& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MSG_DESTROY_PLAYER& default_instance();

  void Swap(MSG_DESTROY_PLAYER* other);

  // implements Message ----------------------------------------------

  MSG_DESTROY_PLAYER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MSG_DESTROY_PLAYER& from);
  void MergeFrom(const MSG_DESTROY_PLAYER& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.MSG_DESTROY_PLAYER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 serial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static MSG_DESTROY_PLAYER* default_instance_;
};
// -------------------------------------------------------------------

class PLAYER_IP : public ::google::protobuf::Message {
 public:
  PLAYER_IP();
  virtual ~PLAYER_IP();

  PLAYER_IP(const PLAYER_IP& from);

  inline PLAYER_IP& operator=(const PLAYER_IP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PLAYER_IP& default_instance();

  void Swap(PLAYER_IP* other);

  // implements Message ----------------------------------------------

  PLAYER_IP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PLAYER_IP& from);
  void MergeFrom(const PLAYER_IP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes playerip = 1;
  inline bool has_playerip() const;
  inline void clear_playerip();
  static const int kPlayeripFieldNumber = 1;
  inline const ::std::string& playerip() const;
  inline void set_playerip(const ::std::string& value);
  inline void set_playerip(const char* value);
  inline void set_playerip(const void* value, size_t size);
  inline ::std::string* mutable_playerip();
  inline ::std::string* release_playerip();
  inline void set_allocated_playerip(::std::string* playerip);

  // @@protoc_insertion_point(class_scope:SFPacketStore.PLAYER_IP)
 private:
  inline void set_has_playerip();
  inline void clear_has_playerip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playerip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static PLAYER_IP* default_instance_;
};
// -------------------------------------------------------------------

class ADD_PEER : public ::google::protobuf::Message {
 public:
  ADD_PEER();
  virtual ~ADD_PEER();

  ADD_PEER(const ADD_PEER& from);

  inline ADD_PEER& operator=(const ADD_PEER& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ADD_PEER& default_instance();

  void Swap(ADD_PEER* other);

  // implements Message ----------------------------------------------

  ADD_PEER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ADD_PEER& from);
  void MergeFrom(const ADD_PEER& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes addpeer = 1;
  inline bool has_addpeer() const;
  inline void clear_addpeer();
  static const int kAddpeerFieldNumber = 1;
  inline const ::std::string& addpeer() const;
  inline void set_addpeer(const ::std::string& value);
  inline void set_addpeer(const char* value);
  inline void set_addpeer(const void* value, size_t size);
  inline ::std::string* mutable_addpeer();
  inline ::std::string* release_addpeer();
  inline void set_allocated_addpeer(::std::string* addpeer);

  // @@protoc_insertion_point(class_scope:SFPacketStore.ADD_PEER)
 private:
  inline void set_has_addpeer();
  inline void clear_has_addpeer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* addpeer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static ADD_PEER* default_instance_;
};
// -------------------------------------------------------------------

class DELETE_PEER : public ::google::protobuf::Message {
 public:
  DELETE_PEER();
  virtual ~DELETE_PEER();

  DELETE_PEER(const DELETE_PEER& from);

  inline DELETE_PEER& operator=(const DELETE_PEER& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DELETE_PEER& default_instance();

  void Swap(DELETE_PEER* other);

  // implements Message ----------------------------------------------

  DELETE_PEER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DELETE_PEER& from);
  void MergeFrom(const DELETE_PEER& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 serial = 1;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 1;
  inline ::google::protobuf::int32 serial() const;
  inline void set_serial(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SFPacketStore.DELETE_PEER)
 private:
  inline void set_has_serial();
  inline void clear_has_serial();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 serial_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_SFPacketStore_2eproto();
  friend void protobuf_AssignDesc_SFPacketStore_2eproto();
  friend void protobuf_ShutdownFile_SFPacketStore_2eproto();

  void InitAsDefaultInstance();
  static DELETE_PEER* default_instance_;
};
// ===================================================================


// ===================================================================

// Login

// required string UserName = 1;
inline bool Login::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Login::username() const {
  return *username_;
}
inline void Login::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Login::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Login::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Password = 2;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Login::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginSuccess

// required int32 Result = 1;
inline bool LoginSuccess::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSuccess::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginSuccess::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginSuccess::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginSuccess::result() const {
  return result_;
}
inline void LoginSuccess::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required bytes UserInfo = 2;
inline bool LoginSuccess::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSuccess::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginSuccess::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginSuccess::clear_userinfo() {
  if (userinfo_ != &::google::protobuf::internal::kEmptyString) {
    userinfo_->clear();
  }
  clear_has_userinfo();
}
inline const ::std::string& LoginSuccess::userinfo() const {
  return *userinfo_;
}
inline void LoginSuccess::set_userinfo(const ::std::string& value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void LoginSuccess::set_userinfo(const char* value) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(value);
}
inline void LoginSuccess::set_userinfo(const void* value, size_t size) {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  userinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSuccess::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    userinfo_ = new ::std::string;
  }
  return userinfo_;
}
inline ::std::string* LoginSuccess::release_userinfo() {
  clear_has_userinfo();
  if (userinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userinfo_;
    userinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSuccess::set_allocated_userinfo(::std::string* userinfo) {
  if (userinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete userinfo_;
  }
  if (userinfo) {
    set_has_userinfo();
    userinfo_ = userinfo;
  } else {
    clear_has_userinfo();
    userinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginFail

// required int32 Result = 1;
inline bool LoginFail::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginFail::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginFail::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginFail::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 LoginFail::result() const {
  return result_;
}
inline void LoginFail::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// TeamInfo_TeamMember

// required string Member = 1;
inline bool TeamInfo_TeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo_TeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfo_TeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfo_TeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& TeamInfo_TeamMember::member() const {
  return *member_;
}
inline void TeamInfo_TeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void TeamInfo_TeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void TeamInfo_TeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamInfo_TeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* TeamInfo_TeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamInfo_TeamMember::set_allocated_member(::std::string* member) {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    delete member_;
  }
  if (member) {
    set_has_member();
    member_ = member;
  } else {
    clear_has_member();
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TeamInfo

// required .SFPacketStore.TeamType Type = 1 [default = RED];
inline bool TeamInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::SFPacketStore::TeamType TeamInfo::type() const {
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void TeamInfo::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .SFPacketStore.TeamInfo.TeamMember Member = 6;
inline int TeamInfo::member_size() const {
  return member_.size();
}
inline void TeamInfo::clear_member() {
  member_.Clear();
}
inline const ::SFPacketStore::TeamInfo_TeamMember& TeamInfo::member(int index) const {
  return member_.Get(index);
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::mutable_member(int index) {
  return member_.Mutable(index);
}
inline ::SFPacketStore::TeamInfo_TeamMember* TeamInfo::add_member() {
  return member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >&
TeamInfo::member() const {
  return member_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::TeamInfo_TeamMember >*
TeamInfo::mutable_member() {
  return &member_;
}

// -------------------------------------------------------------------

// RoomMember_Member

// required string Member = 1;
inline bool RoomMember_Member::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomMember_Member::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomMember_Member::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomMember_Member::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& RoomMember_Member::member() const {
  return *member_;
}
inline void RoomMember_Member::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void RoomMember_Member::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void RoomMember_Member::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomMember_Member::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* RoomMember_Member::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomMember_Member::set_allocated_member(::std::string* member) {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    delete member_;
  }
  if (member) {
    set_has_member();
    member_ = member;
  } else {
    clear_has_member();
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 PlayerIndex = 2;
inline bool RoomMember_Member::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomMember_Member::set_has_playerindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomMember_Member::clear_has_playerindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomMember_Member::clear_playerindex() {
  playerindex_ = 0;
  clear_has_playerindex();
}
inline ::google::protobuf::int32 RoomMember_Member::playerindex() const {
  return playerindex_;
}
inline void RoomMember_Member::set_playerindex(::google::protobuf::int32 value) {
  set_has_playerindex();
  playerindex_ = value;
}

// required .SFPacketStore.TeamType Type = 3;
inline bool RoomMember_Member::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomMember_Member::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomMember_Member::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomMember_Member::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline ::SFPacketStore::TeamType RoomMember_Member::type() const {
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void RoomMember_Member::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// RoomMember

// repeated .SFPacketStore.RoomMember.Member Info = 12;
inline int RoomMember::info_size() const {
  return info_.size();
}
inline void RoomMember::clear_info() {
  info_.Clear();
}
inline const ::SFPacketStore::RoomMember_Member& RoomMember::info(int index) const {
  return info_.Get(index);
}
inline ::SFPacketStore::RoomMember_Member* RoomMember::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::SFPacketStore::RoomMember_Member* RoomMember::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >&
RoomMember::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomMember_Member >*
RoomMember::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// EnterTeamMember

// required string Member = 1;
inline bool EnterTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterTeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterTeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterTeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& EnterTeamMember::member() const {
  return *member_;
}
inline void EnterTeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void EnterTeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void EnterTeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterTeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* EnterTeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterTeamMember::set_allocated_member(::std::string* member) {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    delete member_;
  }
  if (member) {
    set_has_member();
    member_ = member;
  } else {
    clear_has_member();
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 PlayerIndex = 2;
inline bool EnterTeamMember::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterTeamMember::set_has_playerindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterTeamMember::clear_has_playerindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterTeamMember::clear_playerindex() {
  playerindex_ = 0;
  clear_has_playerindex();
}
inline ::google::protobuf::int32 EnterTeamMember::playerindex() const {
  return playerindex_;
}
inline void EnterTeamMember::set_playerindex(::google::protobuf::int32 value) {
  set_has_playerindex();
  playerindex_ = value;
}

// required .SFPacketStore.TeamType Type = 3;
inline bool EnterTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterTeamMember::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterTeamMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterTeamMember::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline ::SFPacketStore::TeamType EnterTeamMember::type() const {
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void EnterTeamMember::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// LeaveTeamMember

// required string Member = 1;
inline bool LeaveTeamMember::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveTeamMember::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveTeamMember::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveTeamMember::clear_member() {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    member_->clear();
  }
  clear_has_member();
}
inline const ::std::string& LeaveTeamMember::member() const {
  return *member_;
}
inline void LeaveTeamMember::set_member(const ::std::string& value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void LeaveTeamMember::set_member(const char* value) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(value);
}
inline void LeaveTeamMember::set_member(const char* value, size_t size) {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  member_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaveTeamMember::mutable_member() {
  set_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    member_ = new ::std::string;
  }
  return member_;
}
inline ::std::string* LeaveTeamMember::release_member() {
  clear_has_member();
  if (member_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = member_;
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LeaveTeamMember::set_allocated_member(::std::string* member) {
  if (member_ != &::google::protobuf::internal::kEmptyString) {
    delete member_;
  }
  if (member) {
    set_has_member();
    member_ = member;
  } else {
    clear_has_member();
    member_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 PlayerIndex = 2;
inline bool LeaveTeamMember::has_playerindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaveTeamMember::set_has_playerindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaveTeamMember::clear_has_playerindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaveTeamMember::clear_playerindex() {
  playerindex_ = 0;
  clear_has_playerindex();
}
inline ::google::protobuf::int32 LeaveTeamMember::playerindex() const {
  return playerindex_;
}
inline void LeaveTeamMember::set_playerindex(::google::protobuf::int32 value) {
  set_has_playerindex();
  playerindex_ = value;
}

// required .SFPacketStore.TeamType Type = 3;
inline bool LeaveTeamMember::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaveTeamMember::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaveTeamMember::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaveTeamMember::clear_type() {
  type_ = -1;
  clear_has_type();
}
inline ::SFPacketStore::TeamType LeaveTeamMember::type() const {
  return static_cast< ::SFPacketStore::TeamType >(type_);
}
inline void LeaveTeamMember::set_type(::SFPacketStore::TeamType value) {
  assert(::SFPacketStore::TeamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// InvalidPacket

// required string Arg = 1;
inline bool InvalidPacket::has_arg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvalidPacket::set_has_arg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvalidPacket::clear_has_arg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvalidPacket::clear_arg() {
  if (arg_ != &::google::protobuf::internal::kEmptyString) {
    arg_->clear();
  }
  clear_has_arg();
}
inline const ::std::string& InvalidPacket::arg() const {
  return *arg_;
}
inline void InvalidPacket::set_arg(const ::std::string& value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
}
inline void InvalidPacket::set_arg(const char* value) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(value);
}
inline void InvalidPacket::set_arg(const char* value, size_t size) {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  arg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InvalidPacket::mutable_arg() {
  set_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    arg_ = new ::std::string;
  }
  return arg_;
}
inline ::std::string* InvalidPacket::release_arg() {
  clear_has_arg();
  if (arg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = arg_;
    arg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InvalidPacket::set_allocated_arg(::std::string* arg) {
  if (arg_ != &::google::protobuf::internal::kEmptyString) {
    delete arg_;
  }
  if (arg) {
    set_has_arg();
    arg_ = arg;
  } else {
    clear_has_arg();
    arg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnterLobby

// optional int32 LobbyIndex = 1 [default = 0];
inline bool EnterLobby::has_lobbyindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterLobby::set_has_lobbyindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterLobby::clear_has_lobbyindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterLobby::clear_lobbyindex() {
  lobbyindex_ = 0;
  clear_has_lobbyindex();
}
inline ::google::protobuf::int32 EnterLobby::lobbyindex() const {
  return lobbyindex_;
}
inline void EnterLobby::set_lobbyindex(::google::protobuf::int32 value) {
  set_has_lobbyindex();
  lobbyindex_ = value;
}

// -------------------------------------------------------------------

// ChatReq

// required string Message = 1;
inline bool ChatReq::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatReq::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatReq::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatReq::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ChatReq::message() const {
  return *message_;
}
inline void ChatReq::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatReq::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatReq::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatReq::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ChatReq::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatReq::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChatRes

// required string Sender = 1;
inline bool ChatRes::has_sender() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChatRes::set_has_sender() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChatRes::clear_has_sender() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChatRes::clear_sender() {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    sender_->clear();
  }
  clear_has_sender();
}
inline const ::std::string& ChatRes::sender() const {
  return *sender_;
}
inline void ChatRes::set_sender(const ::std::string& value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatRes::set_sender(const char* value) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(value);
}
inline void ChatRes::set_sender(const char* value, size_t size) {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  sender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRes::mutable_sender() {
  set_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    sender_ = new ::std::string;
  }
  return sender_;
}
inline ::std::string* ChatRes::release_sender() {
  clear_has_sender();
  if (sender_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_;
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRes::set_allocated_sender(::std::string* sender) {
  if (sender_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_;
  }
  if (sender) {
    set_has_sender();
    sender_ = sender;
  } else {
    clear_has_sender();
    sender_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Message = 2;
inline bool ChatRes::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChatRes::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChatRes::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChatRes::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ChatRes::message() const {
  return *message_;
}
inline void ChatRes::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRes::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ChatRes::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChatRes::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ChatRes::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ChatRes::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EnterRoom

// required int32 RoomIndex = 1;
inline bool EnterRoom::has_roomindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterRoom::set_has_roomindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterRoom::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterRoom::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 EnterRoom::roomindex() const {
  return roomindex_;
}
inline void EnterRoom::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
}

// required int32 GameMode = 2;
inline bool EnterRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterRoom::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterRoom::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterRoom::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 EnterRoom::gamemode() const {
  return gamemode_;
}
inline void EnterRoom::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// optional string Password = 3;
inline bool EnterRoom::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EnterRoom::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EnterRoom::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EnterRoom::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& EnterRoom::password() const {
  return *password_;
}
inline void EnterRoom::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoom::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void EnterRoom::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnterRoom::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* EnterRoom::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnterRoom::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreateRoom

// required int32 GameMode = 1;
inline bool CreateRoom::has_gamemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoom::set_has_gamemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoom::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoom::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 CreateRoom::gamemode() const {
  return gamemode_;
}
inline void CreateRoom::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// optional string Password = 2;
inline bool CreateRoom::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoom::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoom::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoom::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CreateRoom::password() const {
  return *password_;
}
inline void CreateRoom::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoom::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CreateRoom::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateRoom::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CreateRoom::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CreateRoom::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LeaveRoom

// optional int32 Reason = 1 [default = 0];
inline bool LeaveRoom::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaveRoom::set_has_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaveRoom::clear_has_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaveRoom::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
inline ::google::protobuf::int32 LeaveRoom::reason() const {
  return reason_;
}
inline void LeaveRoom::set_reason(::google::protobuf::int32 value) {
  set_has_reason();
  reason_ = value;
}

// -------------------------------------------------------------------

// RoomList_RoomInfo

// required int32 RoomIndex = 1;
inline bool RoomList_RoomInfo::has_roomindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomList_RoomInfo::set_has_roomindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomList_RoomInfo::clear_has_roomindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomList_RoomInfo::clear_roomindex() {
  roomindex_ = 0;
  clear_has_roomindex();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::roomindex() const {
  return roomindex_;
}
inline void RoomList_RoomInfo::set_roomindex(::google::protobuf::int32 value) {
  set_has_roomindex();
  roomindex_ = value;
}

// required string RoomName = 2;
inline bool RoomList_RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomList_RoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomList_RoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomList_RoomInfo::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& RoomList_RoomInfo::roomname() const {
  return *roomname_;
}
inline void RoomList_RoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomList_RoomInfo::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomList_RoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomList_RoomInfo::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* RoomList_RoomInfo::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomList_RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string RoomChief = 3;
inline bool RoomList_RoomInfo::has_roomchief() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomList_RoomInfo::set_has_roomchief() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomList_RoomInfo::clear_has_roomchief() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomList_RoomInfo::clear_roomchief() {
  if (roomchief_ != &::google::protobuf::internal::kEmptyString) {
    roomchief_->clear();
  }
  clear_has_roomchief();
}
inline const ::std::string& RoomList_RoomInfo::roomchief() const {
  return *roomchief_;
}
inline void RoomList_RoomInfo::set_roomchief(const ::std::string& value) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(value);
}
inline void RoomList_RoomInfo::set_roomchief(const char* value) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(value);
}
inline void RoomList_RoomInfo::set_roomchief(const char* value, size_t size) {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  roomchief_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomList_RoomInfo::mutable_roomchief() {
  set_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    roomchief_ = new ::std::string;
  }
  return roomchief_;
}
inline ::std::string* RoomList_RoomInfo::release_roomchief() {
  clear_has_roomchief();
  if (roomchief_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomchief_;
    roomchief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomList_RoomInfo::set_allocated_roomchief(::std::string* roomchief) {
  if (roomchief_ != &::google::protobuf::internal::kEmptyString) {
    delete roomchief_;
  }
  if (roomchief) {
    set_has_roomchief();
    roomchief_ = roomchief;
  } else {
    clear_has_roomchief();
    roomchief_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 UserCount = 4;
inline bool RoomList_RoomInfo::has_usercount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomList_RoomInfo::set_has_usercount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomList_RoomInfo::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomList_RoomInfo::clear_usercount() {
  usercount_ = 0;
  clear_has_usercount();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::usercount() const {
  return usercount_;
}
inline void RoomList_RoomInfo::set_usercount(::google::protobuf::int32 value) {
  set_has_usercount();
  usercount_ = value;
}

// required int32 MaxUserCount = 5;
inline bool RoomList_RoomInfo::has_maxusercount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomList_RoomInfo::set_has_maxusercount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomList_RoomInfo::clear_has_maxusercount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomList_RoomInfo::clear_maxusercount() {
  maxusercount_ = 0;
  clear_has_maxusercount();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::maxusercount() const {
  return maxusercount_;
}
inline void RoomList_RoomInfo::set_maxusercount(::google::protobuf::int32 value) {
  set_has_maxusercount();
  maxusercount_ = value;
}

// required int32 NeedPassword = 6;
inline bool RoomList_RoomInfo::has_needpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomList_RoomInfo::set_has_needpassword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomList_RoomInfo::clear_has_needpassword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomList_RoomInfo::clear_needpassword() {
  needpassword_ = 0;
  clear_has_needpassword();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::needpassword() const {
  return needpassword_;
}
inline void RoomList_RoomInfo::set_needpassword(::google::protobuf::int32 value) {
  set_has_needpassword();
  needpassword_ = value;
}

// required int32 GameMode = 7;
inline bool RoomList_RoomInfo::has_gamemode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoomList_RoomInfo::set_has_gamemode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoomList_RoomInfo::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoomList_RoomInfo::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 RoomList_RoomInfo::gamemode() const {
  return gamemode_;
}
inline void RoomList_RoomInfo::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// -------------------------------------------------------------------

// RoomList

// repeated .SFPacketStore.RoomList.RoomInfo Info = 10;
inline int RoomList::info_size() const {
  return info_.size();
}
inline void RoomList::clear_info() {
  info_.Clear();
}
inline const ::SFPacketStore::RoomList_RoomInfo& RoomList::info(int index) const {
  return info_.Get(index);
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::mutable_info(int index) {
  return info_.Mutable(index);
}
inline ::SFPacketStore::RoomList_RoomInfo* RoomList::add_info() {
  return info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >&
RoomList::info() const {
  return info_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::RoomList_RoomInfo >*
RoomList::mutable_info() {
  return &info_;
}

// -------------------------------------------------------------------

// RoomListRefresh

// -------------------------------------------------------------------

// ChangeTeam

// -------------------------------------------------------------------

// LoadingStart

// -------------------------------------------------------------------

// LoadingComplete

// -------------------------------------------------------------------

// PlayStart

// -------------------------------------------------------------------

// PlayMove

// required float PosX = 1;
inline bool PlayMove::has_posx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayMove::set_has_posx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayMove::clear_has_posx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayMove::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float PlayMove::posx() const {
  return posx_;
}
inline void PlayMove::set_posx(float value) {
  set_has_posx();
  posx_ = value;
}

// required float PosY = 2;
inline bool PlayMove::has_posy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayMove::set_has_posy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayMove::clear_has_posy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayMove::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float PlayMove::posy() const {
  return posy_;
}
inline void PlayMove::set_posy(float value) {
  set_has_posy();
  posy_ = value;
}

// required float PosZ = 3;
inline bool PlayMove::has_posz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayMove::set_has_posz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayMove::clear_has_posz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayMove::clear_posz() {
  posz_ = 0;
  clear_has_posz();
}
inline float PlayMove::posz() const {
  return posz_;
}
inline void PlayMove::set_posz(float value) {
  set_has_posz();
  posz_ = value;
}

// -------------------------------------------------------------------

// PlayEnd

// -------------------------------------------------------------------

// PlayScoreInfo

// required int32 RedKillCount = 1;
inline bool PlayScoreInfo::has_redkillcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayScoreInfo::set_has_redkillcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayScoreInfo::clear_has_redkillcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayScoreInfo::clear_redkillcount() {
  redkillcount_ = 0;
  clear_has_redkillcount();
}
inline ::google::protobuf::int32 PlayScoreInfo::redkillcount() const {
  return redkillcount_;
}
inline void PlayScoreInfo::set_redkillcount(::google::protobuf::int32 value) {
  set_has_redkillcount();
  redkillcount_ = value;
}

// required int32 BlueKillCount = 2;
inline bool PlayScoreInfo::has_bluekillcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayScoreInfo::set_has_bluekillcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayScoreInfo::clear_has_bluekillcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayScoreInfo::clear_bluekillcount() {
  bluekillcount_ = 0;
  clear_has_bluekillcount();
}
inline ::google::protobuf::int32 PlayScoreInfo::bluekillcount() const {
  return bluekillcount_;
}
inline void PlayScoreInfo::set_bluekillcount(::google::protobuf::int32 value) {
  set_has_bluekillcount();
  bluekillcount_ = value;
}

// -------------------------------------------------------------------

// PlayPlayerScore

// required string name = 1;
inline bool PlayPlayerScore::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayPlayerScore::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayPlayerScore::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayPlayerScore::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlayPlayerScore::name() const {
  return *name_;
}
inline void PlayPlayerScore::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayPlayerScore::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlayPlayerScore::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlayPlayerScore::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlayPlayerScore::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PlayPlayerScore::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 teamtype = 2;
inline bool PlayPlayerScore::has_teamtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayPlayerScore::set_has_teamtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayPlayerScore::clear_has_teamtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayPlayerScore::clear_teamtype() {
  teamtype_ = 0;
  clear_has_teamtype();
}
inline ::google::protobuf::int32 PlayPlayerScore::teamtype() const {
  return teamtype_;
}
inline void PlayPlayerScore::set_teamtype(::google::protobuf::int32 value) {
  set_has_teamtype();
  teamtype_ = value;
}

// required int32 kill = 3;
inline bool PlayPlayerScore::has_kill() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayPlayerScore::set_has_kill() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayPlayerScore::clear_has_kill() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayPlayerScore::clear_kill() {
  kill_ = 0;
  clear_has_kill();
}
inline ::google::protobuf::int32 PlayPlayerScore::kill() const {
  return kill_;
}
inline void PlayPlayerScore::set_kill(::google::protobuf::int32 value) {
  set_has_kill();
  kill_ = value;
}

// required int32 death = 4;
inline bool PlayPlayerScore::has_death() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlayPlayerScore::set_has_death() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlayPlayerScore::clear_has_death() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlayPlayerScore::clear_death() {
  death_ = 0;
  clear_has_death();
}
inline ::google::protobuf::int32 PlayPlayerScore::death() const {
  return death_;
}
inline void PlayPlayerScore::set_death(::google::protobuf::int32 value) {
  set_has_death();
  death_ = value;
}

// -------------------------------------------------------------------

// PeerList_PeerInfo

// required int32 serial = 1;
inline bool PeerList_PeerInfo::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerList_PeerInfo::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerList_PeerInfo::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerList_PeerInfo::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 PeerList_PeerInfo::serial() const {
  return serial_;
}
inline void PeerList_PeerInfo::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// required bytes Info = 2;
inline bool PeerList_PeerInfo::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerList_PeerInfo::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerList_PeerInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerList_PeerInfo::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& PeerList_PeerInfo::info() const {
  return *info_;
}
inline void PeerList_PeerInfo::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void PeerList_PeerInfo::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void PeerList_PeerInfo::set_info(const void* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PeerList_PeerInfo::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* PeerList_PeerInfo::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PeerList_PeerInfo::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PeerList

// repeated .SFPacketStore.PeerList.PeerInfo Peer = 10;
inline int PeerList::peer_size() const {
  return peer_.size();
}
inline void PeerList::clear_peer() {
  peer_.Clear();
}
inline const ::SFPacketStore::PeerList_PeerInfo& PeerList::peer(int index) const {
  return peer_.Get(index);
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::mutable_peer(int index) {
  return peer_.Mutable(index);
}
inline ::SFPacketStore::PeerList_PeerInfo* PeerList::add_peer() {
  return peer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >&
PeerList::peer() const {
  return peer_;
}
inline ::google::protobuf::RepeatedPtrField< ::SFPacketStore::PeerList_PeerInfo >*
PeerList::mutable_peer() {
  return &peer_;
}

// -------------------------------------------------------------------

// MSG_CREATE_PLAYER

// required int32 Serial = 1;
inline bool MSG_CREATE_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_CREATE_PLAYER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_CREATE_PLAYER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_CREATE_PLAYER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 MSG_CREATE_PLAYER::serial() const {
  return serial_;
}
inline void MSG_CREATE_PLAYER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// required int32 spawnindex = 2;
inline bool MSG_CREATE_PLAYER::has_spawnindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MSG_CREATE_PLAYER::set_has_spawnindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MSG_CREATE_PLAYER::clear_has_spawnindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MSG_CREATE_PLAYER::clear_spawnindex() {
  spawnindex_ = 0;
  clear_has_spawnindex();
}
inline ::google::protobuf::int32 MSG_CREATE_PLAYER::spawnindex() const {
  return spawnindex_;
}
inline void MSG_CREATE_PLAYER::set_spawnindex(::google::protobuf::int32 value) {
  set_has_spawnindex();
  spawnindex_ = value;
}

// -------------------------------------------------------------------

// MSG_DESTROY_PLAYER

// required int32 Serial = 1;
inline bool MSG_DESTROY_PLAYER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MSG_DESTROY_PLAYER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MSG_DESTROY_PLAYER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MSG_DESTROY_PLAYER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 MSG_DESTROY_PLAYER::serial() const {
  return serial_;
}
inline void MSG_DESTROY_PLAYER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}

// -------------------------------------------------------------------

// PLAYER_IP

// required bytes playerip = 1;
inline bool PLAYER_IP::has_playerip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PLAYER_IP::set_has_playerip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PLAYER_IP::clear_has_playerip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PLAYER_IP::clear_playerip() {
  if (playerip_ != &::google::protobuf::internal::kEmptyString) {
    playerip_->clear();
  }
  clear_has_playerip();
}
inline const ::std::string& PLAYER_IP::playerip() const {
  return *playerip_;
}
inline void PLAYER_IP::set_playerip(const ::std::string& value) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(value);
}
inline void PLAYER_IP::set_playerip(const char* value) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(value);
}
inline void PLAYER_IP::set_playerip(const void* value, size_t size) {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  playerip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PLAYER_IP::mutable_playerip() {
  set_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    playerip_ = new ::std::string;
  }
  return playerip_;
}
inline ::std::string* PLAYER_IP::release_playerip() {
  clear_has_playerip();
  if (playerip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerip_;
    playerip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PLAYER_IP::set_allocated_playerip(::std::string* playerip) {
  if (playerip_ != &::google::protobuf::internal::kEmptyString) {
    delete playerip_;
  }
  if (playerip) {
    set_has_playerip();
    playerip_ = playerip;
  } else {
    clear_has_playerip();
    playerip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ADD_PEER

// required bytes addpeer = 1;
inline bool ADD_PEER::has_addpeer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ADD_PEER::set_has_addpeer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ADD_PEER::clear_has_addpeer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ADD_PEER::clear_addpeer() {
  if (addpeer_ != &::google::protobuf::internal::kEmptyString) {
    addpeer_->clear();
  }
  clear_has_addpeer();
}
inline const ::std::string& ADD_PEER::addpeer() const {
  return *addpeer_;
}
inline void ADD_PEER::set_addpeer(const ::std::string& value) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(value);
}
inline void ADD_PEER::set_addpeer(const char* value) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(value);
}
inline void ADD_PEER::set_addpeer(const void* value, size_t size) {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  addpeer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ADD_PEER::mutable_addpeer() {
  set_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    addpeer_ = new ::std::string;
  }
  return addpeer_;
}
inline ::std::string* ADD_PEER::release_addpeer() {
  clear_has_addpeer();
  if (addpeer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addpeer_;
    addpeer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ADD_PEER::set_allocated_addpeer(::std::string* addpeer) {
  if (addpeer_ != &::google::protobuf::internal::kEmptyString) {
    delete addpeer_;
  }
  if (addpeer) {
    set_has_addpeer();
    addpeer_ = addpeer;
  } else {
    clear_has_addpeer();
    addpeer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DELETE_PEER

// required int32 serial = 1;
inline bool DELETE_PEER::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DELETE_PEER::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DELETE_PEER::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DELETE_PEER::clear_serial() {
  serial_ = 0;
  clear_has_serial();
}
inline ::google::protobuf::int32 DELETE_PEER::serial() const {
  return serial_;
}
inline void DELETE_PEER::set_serial(::google::protobuf::int32 value) {
  set_has_serial();
  serial_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SFPacketStore

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SFPacketStore::TeamType>() {
  return ::SFPacketStore::TeamType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SFPacketStore_2eproto__INCLUDED
